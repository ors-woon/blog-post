---
layout: post
title:  OOP-Book-Review-2.1
tags: Study 
categories: OOP  
---   
이번 포스트에선 SOLID의 O(Open Closed Principle)에 대해 정리했습니다. 
해당 원칙은 (개인적으로) ~~토비의 스프링~~에서 처음 본 원칙으로, OOP 공부를 시작하게 된 이유이기도 합니다. 

> 개방 폐쇄 원칙이라고 불리는 원칙입니다.

#### Open Closed Principle   

Open Closed Principle(이하 OCP) 원칙을 한마디로 정리하면 다음과 같습니다.  

	변경에는 닫혀 있고 확장에는 열려있어야한다. 

~~한마디로 정리하기 어려운 원칙으로~~, 책에서는 이렇게 정리해놨습니다. 

	1. 기능을 변경하거나 확장 할 수 있으면서
	2. 그 기능을 사용하는 코드는 수정하지 않는다.  

(배달부 예제에서) 직원의 종류가 추가되거나, 손님의 지불 방식이 바뀌어도 기존 로직은 바뀌지 않는 걸 생각하시면 됩니다. 즉, 협력관계의 재사용으로 이 원칙을 지킬 수 있게됩니다. 

> OOP의 상속/추상화를 이용하여 지킬 수 있는 원칙입니다. 

#### OCP를 지키지 않는 코드   

(개인적으로) OCP는 Spring을 사용한 적 있다면 지켜지기 쉬운 원칙이라고 생각합니다. 
(대부분 Interface 위주(?)로 작성을 하니까요)

책에서는 OCP 원칙이 깨질 때 아래와 같은 현상이 발생한다고 합니다.  

	1. 다운캐스팅을 한다. + instanceof 를 사용한다.
	2. 비슷한 if-else 블록을 사용한다.   

> 다운 캐스팅을 한다 + instanceof  

상위 함수나, 특정 함수에서 다운 캐스팅 또는 (특정 객체인지 확인 하기 위한) instanceof를 사용할 경우 협력관계를 재사용 할 수 없게 됩니다. 
즉, 특정 자료형에만 종속된 함수가 되기때문에 `개방 폐쇄` 원칙과는 어울리지 않습니다. 

> 비슷한 if-else 블록을 사용한다.  

`비슷한` if-else 블록 이라는 말은, 추상화가 가능 할 정도의 코드를 사용한다는 의미입니다. 
즉, 추상화한 함수의 관계를 형성 할 수 있음에도 그렇게 사용하지 않는 경우를 말합니다.  

만약 if 문에서 새로운 요구사항이 추가될 경우, 기존 코드에 새로운 if 문을 작성해야하며 이 역시 개방 폐쇄와는 맞지 않습니다. 

정리하자면, OCP의 목적은 다음과 같습니다.

	기존 코드를 건들지 않으면서 추가 기능을 구현하자 !!


#### 마치며   

OCP를 지켜지지 않은 코드는 변경에 열려있으며, 확장에는 닫혀있는 코드가 됩니다. 즉, 어떤 기능을 추가할 때 기존코드를 수정해야합니다. 

> 요구사항이 바뀔 때마다 변경되는 코드는 지양해야하는 것은 분명합니다. 

다만, 무리해서 추상화를 할 경우, 불필요한 Interface가 발생하며 이는 (다른 의미에서) 좋지 않은 구조라고 생각합니다. 

> 예를 들어 Spring의 1:1 Interface 매칭이 있습니다 .. (Interface : Impl )

~~AOP 때문도 있다고 알고 있긴 하지만 ...~~
 
책에서는 모든 부분을 추상화 할 필요는 없으며 `변경되는 부분`에 대해서만 추상화를 하라고 언급합니다. 
눈치껏(?) 만들어야합니다 .. 

피드백은 환영입니다.    :D