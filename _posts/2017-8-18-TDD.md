---
layout: post
title: TDD 시행착오
tags:  Test TDD
categories:  Test
---       

#### TDD 시행착오       

Basball Game을 이용한 TDD 영상이 있어서, 그걸 보기전에 먼저 구현해보려 했습니다.    
작년쯤 부터 TDD(Test Driven Developer)라는 개발방법론에 관심이 있어서 몇가지 글을 본적이 있지만 직접 사용하는건 처음이기에 조금 난해한 것같습니다.    

> Basball Game을 구현하면서 느낀 모호함(?) 및 이상함(?)을 정리한 글입니다.     


#### Unit Test    

Unit Test가 중요하다는 것은 대부분의 개발자가 동의하는 내용입니다만...      
실제로 나서서 Unit Test를 하는 사람은 거의 없는것 같습니다.     

> 제 주변 사람들을 기준으로 거의 없더군요         

왜 Unit Test를 잘 안하고, 그 좋다는 TDD를 사용하지 않을까 라는 생각을 하면서 Baseball을 TDD로 구현해 봤습니다.     

> 물론 이 글을 작성하는 지금 TDD를 관뒀습니다.. ..     

#### TDD의 어려움       

TDD의 Flow는 다음과 같습니다.    

1. 돌아가지 않는 Test 코드를 작성한다.
2. 그 코드를 돌아가게 만든다.
3. 리펙토링한다.     

Junit으로 비유하자면 빨간색을 초록색으로 바꾼 후, 리펙토링을 하는 Flow입니다.    

자 이제 위 Flow로 개발을 해봅시다.    

	/**
	 * Baseball Game 
	 * 1. 임의의 숫자 4개를 생성한다.
	 * 2. 사용자는 임의  4개를 입력한다.
	 * 2-1 만약 공통된 부분이 있다면  strike ( 개수 )
	 * 2-2 공통됬지만 위치가 다르다면 ball 
	 * 2-3 공통된 수가 없으면 out 
	 * 3. 기회는 9번
	 * 4. 모두다 맞으면 게임은 끝난다.  
	 */    

	// 필요한 함수.
	// 1. 숫자를 생성하는 함수.
	// 2. 수를 입력받는 함수.
	// 3. 확인하는 함수. 

일단 코드를 작성하기 앞서, Baseball Game의 개념을 이해하고 필요한 함수들을 생각해 봤습니다.    
> 이 과정을 TDD에서는 설계 라고 부릅니다.   

설계를 했으니 빨간색 코드를 만듭시다.      

	@Test
	public void shouldBaseballTest() {
		// 필요한 함수.
		// 1. 숫자를 생성하는 함수.
		// 2. 수를 입력받는 함수.
		// 3. 확인하는 함수. 
		Baseball baseball = new Baseball();
		
		baseball.initGame();
		do {
			baseball.inputNumber();
		}while(!baseball.confirm());
		baseball.printScore();
	}    

돌아간다면 다음과 같은 흐름으로 동작하겠지 라고 생각하며 작성한 코드입니다.     
그후, Baseball class를 만들고 기능을 작성했습니다.     

여기서 2가지 정도의 의문점이 생겼습니다.      

1. 어디까지가 Unit 이지?     
2. 어디까지 검증해야되지 ? 


위에 작성한 함수는  Unit이 아닌 Integration Test같은 느낌이 강하다고 생각했고, 작성하는 내내 어디까지가 Unit인지를 의문이 생겼습니다. 더불어, 만약 각 함수를 Test한다면, 정상적으로 돌아가는걸 어떻게 확인하는지도 궁금해 졌습니다.      

> 초록불은 Test가 완료되었다는 뜻인데, 단순히 Error 없이 끝나는게 아닌, 예상된 값을 뱉어야합니다.        
> 그렇다면 initGame()이 예상된 행위를 했는지 검증을 어떻게해야할지 모르겠더 군요...    

두번째로 내가 검증해야하는 부분이 어디까지인지도 의문점이 생겼습니다. 외부 함수나 다른 API를 사용할 때, 어느 부분까지가 내가 검증해야하는 부분인지 모르겠더군요....     

그래서 개발을 하다가 [영상](https://www.youtube.com/watch?v=960hX13PDuk)을 보고 왔습니다.      

2 번에 대한 답은 얻지 못했지만 ...    
1 번에 대한 답은 얻었습니다 .. !!     

#### 해결하기       

위에서 제가한 방식은 옳은 TDD가 아니였습니다. 예전 방식과 다를바가 없는 코드죠.     
TDD의 핵심은 빠른 Test 주기 입니다. 가장 간단한 부분을 구현 후, 리펙토링하고 한 단계씩 나가면서 이를 반복하는 거죠.      

> 위방식은 main을 설계한 것으로 옳은 설계 방식이 아니였습니다....      
> 제가 이전에 진행한 Test는 광역 단언이라고 합니다.   
> 실패도 자주하고, 실패해도 어디가 문제인지 알 수 없는 Anti - Pattern 이라고 합니다.    

간단하게 다시 해보죠.      

#### Step 01 가장 쉬운것 부터 붉은색 만들기.        

	@Test
	public void shouldNullCheck() {
		Game game = new Game();
		
		try {
			game.vaild(null);
			Assert.fail();
		}catch (IllegalArgumentException e) {
			// TODO: handle exception
		}
	}     

가장 쉬운부분은 입력값에 대한 유효성 검사라고 합니다. 때문에 위같이 null값을 입력받을때의 예외사항을 작성했습니다.     

그 후, Game class와 빈 함수는 vaild 작성했고, 붉은색을 볼 수 있었습니다. 예외처리가 되어있지 않기 때문에  Assert.fail();가 호출된 것입니다.       
    
#### Step 02 초록색으로 만들기        

	public void vaild(String value) {
		if (value == null) {
			throw new IllegalArgumentException();
		}
	}   

Test를 초록색으로 만들기위해 위와같이 코드를 작성했습니다.      
JUnit을 통해 정상적으로 작동하는 걸 확인할 수 있습니다.   

#### Step 03 리펙토링하기.     

해당 코드에서는 너무 작은 부분이라 리펙토링할게 없지만, Test를 작성하면서 리펙토링이 필요하면 그때마다 진행을 한다고합니다.        

> 이전 Test과 겹치는 부분들이 있으면 함께 리펙토링할 수도 있습니다.    

#### 다시 Step 01로 돌아가기.     

step03 까지 완료했다면, 다음 기능을 구현하기위해 01로 돌아가 계속 TDD를 진행합니다.    
결국 TDD는 짧은 test 주기를 통해서, 코드의 신뢰도를 더해가는 과정이라고 생각합니다.

#### 마치며       

이와같이 개발을 할 경우, 그때마다 리펙토링을 진행 할수 있고, 각 Test Case에 대해 신뢰도를 얻을 수 있을 뿐더러, 다른 사람이 테스트 코드 만으로도 해당 기능을 이해 할 수 있다는 장점을 얻을 수 있습니다.    

> 물론 이상하게 짜면 다른 사람이 이해 할 순 없겟죠 ... ?    

Baseball Game을 통해 TDD를 조금 더 연습해 보고, 한번더 정리해봐야겠습니다.....      



2017-08-18            

       

lusiue@naver.com