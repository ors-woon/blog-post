<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jang chulwoon</title>
    <description>공부하고 싶었던 내용을 정리하고있습니다</description>
    <link>http://localhost:8080/</link>
    <atom:link href="http://localhost:8080/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 03 Nov 2016 08:44:02 +0000</pubDate>
    <lastBuildDate>Thu, 03 Nov 2016 08:44:02 +0000</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>equals 와 Hashcode [1] </title>
        <description>&lt;h2 id=&quot;hashcode--equals-1&quot;&gt;hashCode 와 equals [1]&lt;/h2&gt;

&lt;p&gt;hashCode()와 equals() method 는 Object에 속해있는 method 입니다.  &lt;br /&gt;
Java에서 Object class 는 모든 클레스의 superclass 입니다. &lt;br /&gt;
때문에 Java의 모든 class 는 Object의 method를 구현하고 있습니다. &lt;br /&gt;
자세한 내용은 &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;을 참고해주세요.&lt;/p&gt;

&lt;h2 id=&quot;equals&quot;&gt;equals()&lt;/h2&gt;

&lt;p&gt;equals() method 는 동등성을 비교 할 때 사용됩니다. &lt;br /&gt;
간략하게 정리하면 equals()는 다른 객체가 특정 객체와 동일한가를 구현한 method 입니다.     Java doc에서는 equals()의 설명을 다음과 같이 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The equals method implements an equivalence relation on non-null object references:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;equals method는 null값이 아닌 object 간의 &lt;strong&gt;동치성&lt;/strong&gt;을 구현하는 method 입니다.  &lt;br /&gt;
또한 equals method를 재정의 하려 한다면, 동치성을 만족시켜야 합니다.&lt;/p&gt;

&lt;p&gt;동치성을 만족하기 위한 몇가지 특징들은 다음과 같습니다. &lt;br /&gt;
(어찌보면 당연한 내용일 수 있습니다 ..)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;재귀  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is reflexive: for any non-null reference value x, x.equals(x) should return true.&lt;/code&gt;    &lt;br /&gt;
null 이외의 참조값 x 에 대해 x.equals(x)는 항상 true 여야만 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대칭 
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.&lt;/code&gt; &lt;br /&gt;
null 이외의 참조값 x 와 y 에 대해 y.equals(x)가 true 이면 x.equals(y) 또한 true가 되야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이적 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. &lt;/code&gt;  &lt;br /&gt;
null 이외의 참조값 x , y ,z 에 대해, x.equals(y)가 ture를 반환하고 y.equals(z)가 ture 반환하면 x.equals(z) 또한 ture를 반환해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일관 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.&lt;/code&gt;     &lt;br /&gt;
null 이외의 참조값 x , y 에 대해, equals를 통해 비교되는 정보에 수정이 없다면, x.equals(y)의 호출의 결과는 계속해서 true나 false여야합니다.     &lt;br /&gt;
(정보의 변화가 없다면 반환 값은 항상 일관되어져야 합니다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;null  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;For any non-null reference value x, x.equals(null) should return false.&lt;/code&gt;&lt;br /&gt;
null이 아닌 참조값 x에 대해, x.equals(null)은 항상 false 입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;코드 없이 언어로만 정리하면 당연한거 아닌가? 라는 생각이 듭니다. (저만 그런가요 ?)  &lt;br /&gt;
코드와 함께 정리해보겠습니다 …&lt;/p&gt;

&lt;h3 id=&quot;object--equals&quot;&gt;Object 의 equals()&lt;/h3&gt;

&lt;p&gt;들어가기 앞서 , effective Java 에서는 equals method 를 재정의 하지 않아도 되는 경우를 다음과 같이 설명했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 객체가 고유한 경우. (ex Singleton )&lt;/li&gt;
  &lt;li&gt;상위 클래스에서 재정의한 equals method가 하위클래스에서 사용하기 적절한 경우.&lt;/li&gt;
  &lt;li&gt;class가 private 또는 package-private 로 선언되있고, equals 를 호출 할 일이 없는 경우.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 동일성&lt;/strong&gt; 검사 방법이 있건 없건 상관없는 경우.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리적 동일성을 지원하는 클래스일 경우엔, equals를 재정의하는게 바람직하다고 말합니다. &lt;br /&gt;
( 대표적으로 Integer / Date 클래스가 이에 해당한다고 합니다. )     &lt;br /&gt;
논리적 동일성은 객체가 동일한가?가 아닌 객체 안에 있는 값이 동일한가를 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 조건을 만족하지 않는다면 , 재정의하는 것을 생각해 봐야합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 , 어떻게 재정의를 해야할까요 ?&lt;/p&gt;

&lt;p&gt;object의 equals method&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	 public boolean equals(Object obj) {
        return (this == obj);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Integer의 equals method&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Integer의 equals 를 보면 우선 인자의 obj가 Integer type 인지 확인을 한 후, &lt;br /&gt;
맞다면, 기존 객체에 저장된 값과 넘어온 인자의 값이 같으면 true를 반환하는 방식입니다.&lt;/p&gt;

&lt;p&gt;~ ing ..  &lt;br /&gt;
( equals를 잘못구현한 예제를 찾아보고 있습니다. )&lt;/p&gt;

&lt;p&gt;참조 &lt;br /&gt;
[1] &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;   &lt;br /&gt;
[2] &lt;a href=&quot;`http://egloos.zum.com/iilii/v/3999066`&quot;&gt;건실성실착실 3실 청년!&lt;/a&gt; &lt;br /&gt;
[3] effective Java&lt;/p&gt;

</description>
        <pubDate>Thu, 03 Nov 2016 08:32:00 +0000</pubDate>
        <link>http://localhost:8080/2016/11/03/equals_hashcode.html</link>
        <guid isPermaLink="true">http://localhost:8080/2016/11/03/equals_hashcode.html</guid>
        
        <category>Java</category>
        
        <category>equals</category>
        
        
      </item>
    
      <item>
        <title>Java-Collection[1] </title>
        <description>&lt;h2 id=&quot;collection&quot;&gt;Collection&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;본 글은 Java Collection Interface를 정리한 글입니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;세부 내용은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java doc&lt;/a&gt;에서 확인하세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Collection 이란&lt;br /&gt;
여러 객체의 그룹으로, Collection 인터페이스는 Collection 계층의 &lt;strong&gt;root interface&lt;/strong&gt; 입니다.  &lt;br /&gt;
(List / Queue Interface 등의 상위 Interface 입니다.  )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collection의 subInterface&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BeanContext, BeanContextServices, BlockingDeque&lt;E&gt;, BlockingQueue&lt;E&gt;, Deque&lt;E&gt;, List&lt;E&gt;....&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 JDK에서는 Collection 인터페이스를 직접적으로 구현하는 것을 제공하지 않고, &lt;strong&gt;Set , List&lt;/strong&gt; 같이 서브인터페이스로 구현을 제공합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(+) Multisets은 직접적으로 인터페이스를 구현해야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Collection을 구현하는서브인터페이스는 2개의 생성자를 구현해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;default 생성자와 Collection Type의 단일 인자를 받는 생성자 입니다. 인자를 받는 경우 collection을 복제 할 수 있어 원하는 타입의 동등한 collection을 생성 할 수 있습니다. 이 두가지 생성자가 강요되는 것은 아니지만 모든 Java Platform Library의 Colletion Interface는 이를 준수하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public ArrayList(int initialCapacity) {
        if (initialCapacity &amp;gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection의 서브인터페이스인 List를 구현한 ArrayList입니다. &lt;br /&gt;
ArrayList는 3가지의 생성자를 갖고 있는데, 그 중 2가지의 생성자는 위에서 말씀드린 생성자 입니다. &lt;br /&gt;
2번째 생성자는 collection type의 인자를 받아 복제하여 사용하는 코드입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;만약 collection이 작동을 지원하지 않는다면 UnsupportedOperationException을 던집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기능을 지원하지 않는 경우 발생하는 Exception&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;몇몇 collection 인터페이스는 인자에 대한 제한을 갖고 있습니다. &lt;br /&gt;
null 인자를 금지한다거나, 그들의 속성값의 제한을 합니다.&lt;br /&gt;
만약 자격이 없는 인자를 추가하려고 시도한다면 확인되지 않은 exception을 던질것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 nullpointerException(null 값 문제) 이나 ClassCastException(캐스팅 문제)을 던집니다.&lt;br /&gt;
위 생성자를 보시면 collection의 인자가 Null일 경우 nullpointerException을 던진다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;method&quot;&gt;Method&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 8에 추가된 default method는 제외하고 정리해 보았습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean add(E e)   &lt;br /&gt;
Collection은 제네릭을 이용하여 선언됩니다. ( ex - List&lt;Integer&gt; list )     
해당 타입의 변수를 넘겨 받아 Collection에 추가하는 Method 입니다. ( ex - list.add(5) )&lt;/Integer&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;의미 그대로 element를 삽입하는 Method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
    &lt;blockquote&gt;
      &lt;p&gt;method를 정리하기 전에 (Collection&amp;lt;? extends E&amp;gt; c) 부터 정리하겠습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추후 정리할 내용인 제네릭과 관련있는 부분입니다 ( ?를 &lt;strong&gt;와일드카드 타입&lt;/strong&gt;이라 부릅니다. ).   &lt;br /&gt;
class 상속받을때 쓰는 extends 의미 그대로,  &amp;lt;? extends E&amp;gt; 는 E를 상속 받은 타입을 말합니다.   &lt;br /&gt;
즉 E 의 하위타입 또는 E 타입의 인자를 받겠다는 뜻입니다.    &lt;br /&gt;
만약 &amp;lt;? extends List&amp;gt; 로 쓰인다면 List 의 하위 클래스인 ArrayList , Linked List 등의 타입이 인자로 올 수 있습니다.   &lt;br /&gt;
다만, 상위 클래스에서 정의된 메소드만 사용 할 수 있습니다.   &lt;br /&gt;
하위 클래스에서만 정의된 메소드를 사용시 에러를 낸다고합니다.&lt;/p&gt;

&lt;p&gt;(예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    interface People {
        void eat();
        void sleep();
    }

    class Student implements  People {
    
        @Override
        public void eat() {
            System.out.println(&quot;nice food  !&quot;);
        }
    
        @Override
        public void sleep() {
            System.out.println(&quot;zzzzzz !&quot;);
        }
        public void study(){
            System.out.println(&quot;studying !&quot;);
        }
    }


    public class Main {
        public static void act(List&amp;lt;? extends People&amp;gt; people){
            people.get(0).eat();
            //people.get(0).study(); 이부분은 컴파일 에러가 나옵니다.
    
        }
        public static void main(String args[]){
            List&amp;lt;Student&amp;gt; list = new ArrayList();
            Student student = new Student();
            list.add(student);
            act(list);
        }
    }   

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다시 method 설명으로 돌아와서 , addAll method 는  인자로 받은 collection 타입의 element들을 모두 추가하는 메소드 입니다.    &lt;br /&gt;
자세한 내용은 collection을 구현하고 있는 하위 클래스를 분석하며 정리하도록 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection 타입의 element를 해당 collection에 추가하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;void clear()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;의미 그대로 해당 collection에 있는 모든 인자를 clear 하는 method 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 Collection의 모든 element를 지웁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean contains(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 o 가 collection에 있으면 true를 반환. 없으면 false를 반환한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 elements 가 있는지 확인하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean containAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 collection의 element 모두가  해당 collection에 있으면 true를 반환합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection의 모든 element가 포함되어있는지 확인하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean equeals(Object o)&lt;/li&gt;
  &lt;li&gt;int hashCode() &lt;br /&gt;
동일성과 동등성을 체크하기위한 method . &lt;br /&gt;
Object 클래스에서 상속받아 구현하기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;설명 할 내용이 많기 때문에 추후 이 주제로 정리하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean isEmpty()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection이 비어있으면 true를 반환. 비어있지 않으면 false를 반환.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator&lt;E&gt; iterator()&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator 를 구현하기 위한 method . 이또한 추후 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean remove(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;값을 넘겨받은 object element를 삭제하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean removeAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 삭제하는 method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean retainAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 유지하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ArrayList를 찾아보며 정리하던 중 , removeAll 과 retainAll의 동작 방식이 같다는 걸 알게 되었습니다. 찾아보니 bug 라고 하더군요 … (제가 갖고있는 버전에 문제가 있던것 같습니다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8372576/java-commons-collections-removeall&quot;&gt;자세한 설명&lt;/a&gt;을 참고해 주세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int size()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 size를 반환하는 메소드 입니다 . (가장 많이 접했던 method가 아닐까합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Object[] toArray()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 element들을 object 타입의 array로 변환하여 반환하는 method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;T&gt; T[] toArray()

&lt;/T&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
  &lt;p&gt;이전의 toArray와 같은 방식으로 array를 반환하지만, 제네릭을 사용하여 타입을 사용자가 정할 수 있다는 차이가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;추후 Collection을 상속받은 List를 정리하면서 오늘 설명하지 못한 부분들을 정리하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;p&gt;~ 2016 - 10 -31&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Oct 2016 10:32:00 +0000</pubDate>
        <link>http://localhost:8080/2016/10/26/Collection.html</link>
        <guid isPermaLink="true">http://localhost:8080/2016/10/26/Collection.html</guid>
        
        <category>Java</category>
        
        <category>Collection</category>
        
        
      </item>
    
      <item>
        <title>Hello? </title>
        <description>&lt;p&gt;Hello?&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Oct 2016 10:32:00 +0000</pubDate>
        <link>http://localhost:8080/2016/10/20/Hello.html</link>
        <guid isPermaLink="true">http://localhost:8080/2016/10/20/Hello.html</guid>
        
        <category>world</category>
        
        <category>hello</category>
        
        
      </item>
    
  </channel>
</rss>