<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Jang chulwoon</title>
 <link href="http://localhost:8080/atom.xml" rel="self"/>
 <link href="http://localhost:8080"/>
 <updated>2016-11-03T08:35:17+00:00</updated>
 <id>http://localhost:8080</id>
 <author>
   <name></name>
   <email>ㅣlusiue@gmail.com</email>
 </author>

 
 <entry>
   <title>Java-Collection[1] </title>
   <link href="http://localhost:8080/2016/10/26/Collection.html"/>
   <updated>2016-10-26T10:32:00+00:00</updated>
   <id>http://localhost:8080/2016/10/26/Collection</id>
   <content type="html">&lt;h2 id=&quot;collection&quot;&gt;Collection&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;본 글은 Java Collection Interface를 정리한 글입니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;세부 내용은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java doc&lt;/a&gt;에서 확인하세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Collection 이란&lt;br /&gt;
여러 객체의 그룹으로, Collection 인터페이스는 Collection 계층의 &lt;strong&gt;root interface&lt;/strong&gt; 입니다.  &lt;br /&gt;
(List / Queue Interface 등의 상위 Interface 입니다.  )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collection의 subInterface&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BeanContext, BeanContextServices, BlockingDeque&lt;E&gt;, BlockingQueue&lt;E&gt;, Deque&lt;E&gt;, List&lt;E&gt;....&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 JDK에서는 Collection 인터페이스를 직접적으로 구현하는 것을 제공하지 않고, &lt;strong&gt;Set , List&lt;/strong&gt; 같이 서브인터페이스로 구현을 제공합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(+) Multisets은 직접적으로 인터페이스를 구현해야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Collection을 구현하는서브인터페이스는 2개의 생성자를 구현해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;default 생성자와 Collection Type의 단일 인자를 받는 생성자 입니다. 인자를 받는 경우 collection을 복제 할 수 있어 원하는 타입의 동등한 collection을 생성 할 수 있습니다. 이 두가지 생성자가 강요되는 것은 아니지만 모든 Java Platform Library의 Colletion Interface는 이를 준수하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public ArrayList(int initialCapacity) {
        if (initialCapacity &amp;gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection의 서브인터페이스인 List를 구현한 ArrayList입니다. &lt;br /&gt;
ArrayList는 3가지의 생성자를 갖고 있는데, 그 중 2가지의 생성자는 위에서 말씀드린 생성자 입니다. &lt;br /&gt;
2번째 생성자는 collection type의 인자를 받아 복제하여 사용하는 코드입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;만약 collection이 작동을 지원하지 않는다면 UnsupportedOperationException을 던집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기능을 지원하지 않는 경우 발생하는 Exception&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;몇몇 collection 인터페이스는 인자에 대한 제한을 갖고 있습니다. &lt;br /&gt;
null 인자를 금지한다거나, 그들의 속성값의 제한을 합니다.&lt;br /&gt;
만약 자격이 없는 인자를 추가하려고 시도한다면 확인되지 않은 exception을 던질것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 nullpointerException(null 값 문제) 이나 ClassCastException(캐스팅 문제)을 던집니다.&lt;br /&gt;
위 생성자를 보시면 collection의 인자가 Null일 경우 nullpointerException을 던진다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;method&quot;&gt;Method&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 8에 추가된 default method는 제외하고 정리해 보았습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean add(E e)   &lt;br /&gt;
Collection은 제네릭을 이용하여 선언됩니다. ( ex - List&lt;Integer&gt; list )     
해당 타입의 변수를 넘겨 받아 Collection에 추가하는 Method 입니다. ( ex - list.add(5) )&lt;/Integer&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;의미 그대로 element를 삽입하는 Method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
    &lt;blockquote&gt;
      &lt;p&gt;method를 정리하기 전에 (Collection&amp;lt;? extends E&amp;gt; c) 부터 정리하겠습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추후 정리할 내용인 제네릭과 관련있는 부분입니다 ( ?를 &lt;strong&gt;와일드카드 타입&lt;/strong&gt;이라 부릅니다. ).   &lt;br /&gt;
class 상속받을때 쓰는 extends 의미 그대로,  &amp;lt;? extends E&amp;gt; 는 E를 상속 받은 타입을 말합니다.   &lt;br /&gt;
즉 E 의 하위타입 또는 E 타입의 인자를 받겠다는 뜻입니다.    &lt;br /&gt;
만약 &amp;lt;? extends List&amp;gt; 로 쓰인다면 List 의 하위 클래스인 ArrayList , Linked List 등의 타입이 인자로 올 수 있습니다.   &lt;br /&gt;
다만, 상위 클래스에서 정의된 메소드만 사용 할 수 있습니다.   &lt;br /&gt;
하위 클래스에서만 정의된 메소드를 사용시 에러를 낸다고합니다.&lt;/p&gt;

&lt;p&gt;(예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    interface People {
        void eat();
        void sleep();
    }

    class Student implements  People {
    
        @Override
        public void eat() {
            System.out.println(&quot;nice food  !&quot;);
        }
    
        @Override
        public void sleep() {
            System.out.println(&quot;zzzzzz !&quot;);
        }
        public void study(){
            System.out.println(&quot;studying !&quot;);
        }
    }


    public class Main {
        public static void act(List&amp;lt;? extends People&amp;gt; people){
            people.get(0).eat();
            //people.get(0).study(); 이부분은 컴파일 에러가 나옵니다.
    
        }
        public static void main(String args[]){
            List&amp;lt;Student&amp;gt; list = new ArrayList();
            Student student = new Student();
            list.add(student);
            act(list);
        }
    }   

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다시 method 설명으로 돌아와서 , addAll method 는  인자로 받은 collection 타입의 element들을 모두 추가하는 메소드 입니다.    &lt;br /&gt;
자세한 내용은 collection을 구현하고 있는 하위 클래스를 분석하며 정리하도록 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection 타입의 element를 해당 collection에 추가하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;void clear()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;의미 그대로 해당 collection에 있는 모든 인자를 clear 하는 method 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 Collection의 모든 element를 지웁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean contains(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 o 가 collection에 있으면 true를 반환. 없으면 false를 반환한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 elements 가 있는지 확인하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean containAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 collection의 element 모두가  해당 collection에 있으면 true를 반환합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection의 모든 element가 포함되어있는지 확인하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean equeals(Object o)&lt;/li&gt;
  &lt;li&gt;int hashCode() &lt;br /&gt;
동일성과 동등성을 체크하기위한 method . &lt;br /&gt;
Object 클래스에서 상속받아 구현하기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;설명 할 내용이 많기 때문에 추후 이 주제로 정리하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean isEmpty()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection이 비어있으면 true를 반환. 비어있지 않으면 false를 반환.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator&lt;E&gt; iterator()&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator 를 구현하기 위한 method . 이또한 추후 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean remove(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;값을 넘겨받은 object element를 삭제하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean removeAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 삭제하는 method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean retainAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 유지하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ArrayList를 찾아보며 정리하던 중 , removeAll 과 retainAll의 동작 방식이 같다는 걸 알게 되었습니다. 찾아보니 bug 라고 하더군요 … (제가 갖고있는 버전에 문제가 있던것 같습니다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8372576/java-commons-collections-removeall&quot;&gt;자세한 설명&lt;/a&gt;을 참고해 주세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int size()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 size를 반환하는 메소드 입니다 . (가장 많이 접했던 method가 아닐까합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Object[] toArray()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 element들을 object 타입의 array로 변환하여 반환하는 method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;T&gt; T[] toArray()

&lt;/T&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
  &lt;p&gt;이전의 toArray와 같은 방식으로 array를 반환하지만, 제네릭을 사용하여 타입을 사용자가 정할 수 있다는 차이가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;추후 Collection을 상속받은 List를 정리하면서 오늘 설명하지 못한 부분들을 정리하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;p&gt;~ 2016 - 10 -31&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Hello? </title>
   <link href="http://localhost:8080/2016/10/20/Hello.html"/>
   <updated>2016-10-20T10:32:00+00:00</updated>
   <id>http://localhost:8080/2016/10/20/Hello</id>
   <content type="html">&lt;p&gt;Hello?&lt;/p&gt;
</content>
 </entry>
 
 
</feed>